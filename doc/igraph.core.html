<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><title>igraph.core documentation</title><link rel="stylesheet" type="text/css" href="css/default.css" /><link rel="stylesheet" type="text/css" href="css/highlight.css" /><script type="text/javascript" src="js/highlight.min.js"></script><script type="text/javascript" src="js/jquery.min.js"></script><script type="text/javascript" src="js/page_effects.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html"><span class="project-title"><span class="project-name">Igraph</span> <span class="project-version">0.1.4-SNAPSHOT</span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Topics</span></h3><ul><li class="depth-1 "><a href="intro.html"><div class="inner"><span>Introduction to igraph</span></div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>igraph</span></div></div></li><li class="depth-2 branch current"><a href="igraph.core.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>core</span></div></a></li><li class="depth-2"><a href="igraph.graph.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>graph</span></div></a></li></ul></div><div class="sidebar secondary"><h3><a href="#top"><span class="inner">Public Vars</span></a></h3><ul><li class="depth-1"><a href="igraph.core.html#var-add-to-graph"><div class="inner"><span>add-to-graph</span></div></a></li><li class="depth-1"><a href="igraph.core.html#var-alter-graph-dispatcher"><div class="inner"><span>alter-graph-dispatcher</span></div></a></li><li class="depth-1"><a href="igraph.core.html#var-IGraph"><div class="inner"><span>IGraph</span></div></a></li><li class="depth-2 branch"><a href="igraph.core.html#var-add"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>add</span></div></a></li><li class="depth-2 branch"><a href="igraph.core.html#var-ask"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>ask</span></div></a></li><li class="depth-2 branch"><a href="igraph.core.html#var-get-o"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>get-o</span></div></a></li><li class="depth-2 branch"><a href="igraph.core.html#var-get-p-o"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>get-p-o</span></div></a></li><li class="depth-2 branch"><a href="igraph.core.html#var-invoke"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>invoke</span></div></a></li><li class="depth-2 branch"><a href="igraph.core.html#var-normal-form"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>normal-form</span></div></a></li><li class="depth-2 branch"><a href="igraph.core.html#var-query"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>query</span></div></a></li><li class="depth-2 branch"><a href="igraph.core.html#var-read-only.3F"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>read-only?</span></div></a></li><li class="depth-2 branch"><a href="igraph.core.html#var-subjects"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>subjects</span></div></a></li><li class="depth-2"><a href="igraph.core.html#var-subtract"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>subtract</span></div></a></li><li class="depth-1"><a href="igraph.core.html#var-ISet"><div class="inner"><span>ISet</span></div></a></li><li class="depth-2 branch"><a href="igraph.core.html#var-difference"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>difference</span></div></a></li><li class="depth-2 branch"><a href="igraph.core.html#var-intersection"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>intersection</span></div></a></li><li class="depth-2"><a href="igraph.core.html#var-union"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>union</span></div></a></li><li class="depth-1"><a href="igraph.core.html#var-match-or-traverse"><div class="inner"><span>match-or-traverse</span></div></a></li><li class="depth-1"><a href="igraph.core.html#var-normal-form.3F"><div class="inner"><span>normal-form?</span></div></a></li><li class="depth-1"><a href="igraph.core.html#var-p-dispatcher"><div class="inner"><span>p-dispatcher</span></div></a></li><li class="depth-1"><a href="igraph.core.html#var-remove-from-graph"><div class="inner"><span>remove-from-graph</span></div></a></li><li class="depth-1"><a href="igraph.core.html#var-transitive-closure"><div class="inner"><span>transitive-closure</span></div></a></li><li class="depth-1"><a href="igraph.core.html#var-traverse"><div class="inner"><span>traverse</span></div></a></li><li class="depth-1"><a href="igraph.core.html#var-traverse-link"><div class="inner"><span>traverse-link</span></div></a></li><li class="depth-1"><a href="igraph.core.html#var-unique"><div class="inner"><span>unique</span></div></a></li></ul></div><div class="namespace-docs" id="content"><h1 class="anchor" id="top">igraph.core</h1><div class="doc"><pre class="plaintext">Abstractions over a graph object, intended to sit alongside the 
other basic clojure data structures such as maps and sequences.</pre></div><div class="public anchor" id="var-add-to-graph"><h3>add-to-graph</h3><h4 class="type">multimethod</h4><div class="usage"></div><div class="doc"><pre class="plaintext">Returns &lt;g&gt;, with &lt;to-add&gt; added
Where
&lt;g&gt; is a Graph
&lt;to-add&gt; is interpetable as a set of triples
Dispatched according to `alter-graph-dispatcher`
</pre></div></div><div class="public anchor" id="var-alter-graph-dispatcher"><h3>alter-graph-dispatcher</h3><div class="usage"><code>(alter-graph-dispatcher g to-add-or-remove)</code></div><div class="doc"><pre class="plaintext">Returns one of #{:vector :vector-of-vectors :normal-form &lt;type&gt;} for &lt;args&gt;
Where
&lt;args&gt; := [&lt;g&gt; &lt;to-add-or-remove&gt;],  arguments to a method add or remove from graph
&lt;g&gt; is a graph
&lt;to-add-or-remove&gt; is a specification of triples to add to or remove from  &lt;g&gt;
&lt;triple&gt; indicates &lt;to-add-or-remove&gt; := [&lt;s&gt; &lt;p&gt; &lt;o&gt;]
&lt;vector-of-vectors&gt; indicates &lt;to-add-or-remove&gt; := [&lt;triple&gt;...]
&lt;type&gt; = (type &lt;to-add&gt;)
</pre></div></div><div class="public anchor" id="var-IGraph"><h3>IGraph</h3><h4 class="type">protocol</h4><div class="usage"></div><div class="doc"><pre class="plaintext">An abstraction for S-P-O graphs
</pre></div><div class="members"><h4>members</h4><div class="inner"><div class="public anchor" id="var-add"><h3>add</h3><div class="usage"><code>(add g to-add)</code></div><div class="doc"><pre class="plaintext">Returns &lt;g&gt;, with &lt;to-add&gt; added to its contents.
Throws an exception if (read-only? &lt;g&gt;)
Where
&lt;g&gt; is a graph
&lt;to-add&gt; is in some format interpretable as a set of triples.</pre></div></div><div class="public anchor" id="var-ask"><h3>ask</h3><div class="usage"><code>(ask g s p o)</code></div><div class="doc"><pre class="plaintext">Returns truthy value iff [&lt;s&gt; &lt;p&gt; &lt;o&gt;] appears in &lt;g&gt;
Where
&lt;g&gt; is a graph
&lt;s&gt; is subject of some triples in &lt;g&gt;
&lt;p&gt; is predicate of some triples in &lt;g&gt;
&lt;o&gt; appears in triple [&lt;s&gt; &lt;p&gt; &lt;o&gt;] in &lt;g&gt;</pre></div></div><div class="public anchor" id="var-get-o"><h3>get-o</h3><div class="usage"><code>(get-o g s p)</code></div><div class="doc"><pre class="plaintext">Returns {&lt;o&gt; ...} for &lt;s&gt; and &lt;p&gt; in &lt;g&gt;, or nil.
Where
&lt;g&gt; is a graph
&lt;s&gt; is subject of some triples in &lt;g&gt;
&lt;p&gt; is predicate of some triples in &lt;g&gt;
&lt;o&gt; appears in triple [&lt;s&gt; &lt;p&gt; &lt;o&gt;] in &lt;g&gt;</pre></div></div><div class="public anchor" id="var-get-p-o"><h3>get-p-o</h3><div class="usage"><code>(get-p-o g s)</code></div><div class="doc"><pre class="plaintext">Returns {&lt;p&gt; #{&lt;o&gt; ...}} associated with &lt;s&gt; in &lt;g&gt;, or nil.
Where
&lt;g&gt; is a graph
&lt;s&gt; is subject 
&lt;p&gt; and &lt;o&gt; are in triples := [&lt;s&gt; &lt;p&gt; &lt;o&gt;] in &lt;g&gt;</pre></div></div><div class="public anchor" id="var-invoke"><h3>invoke</h3><div class="usage"><code>(invoke g)</code><code>(invoke g s)</code><code>(invoke g s p)</code><code>(invoke g s p o)</code></div><div class="doc"><pre class="plaintext">Applies &lt;g&gt; as a function to the rest of its arguments, representing 
   triples [&lt;s&gt; &lt;p&gt; &lt;o&gt;] in &lt;g&gt; respectively. &lt;p&gt; may optionally be 
   a traversal function (See `traverse` docs)
(g) -&gt; {&lt;s&gt; {&lt;p&gt; #{&lt;o&gt;...}...}...} ;; = (normal-form &lt;g&gt;)
(g s) -&gt; {&lt;p&gt; #{&lt;o&gt;...}, ...} ;; = (get-p-o &lt;g&gt;)
(g s p) -&gt; #{&lt;o&gt; ...} ;; = (match-or-traverse g s p)
(g s p o) -&gt; &lt;o&gt; iff [&lt;s&gt; &lt;p&gt; &lt;o&gt;] is in &lt;g&gt; ;; = (match-or-traverse g s p o)</pre></div></div><div class="public anchor" id="var-normal-form"><h3>normal-form</h3><div class="usage"><code>(normal-form g)</code></div><div class="doc"><pre class="plaintext">Returns {&lt;s&gt; {&lt;p&gt; #{&lt;o&gt;...}...}...}
Where 
&lt;s&gt; is the subject of a triple := [&lt;s&gt; &lt;p&gt; &lt;o&gt;] in &lt;g&gt;
&lt;p&gt; is predicate of same
&lt;o&gt; is the object of same</pre></div></div><div class="public anchor" id="var-query"><h3>query</h3><div class="usage"><code>(query g q)</code></div><div class="doc"><pre class="plaintext">Returns #{&lt;binding&gt; ...} for query spec &lt;q&gt; applied to &lt;g&gt;
Where
&lt;binding&gt; := {&lt;var&gt; &lt;value&gt;, ...}
&lt;q&gt; is a query specification suitable for the native format of &lt;g&gt;
&lt;g&gt; is a graph
&lt;args&gt; := [&lt;arg&gt;....]
&lt;var&gt; is a variable specified in &lt;q&gt;
&lt;value&gt; is a value found in &lt;g&gt; bounded to &lt;var&gt; per &lt;q&gt;
&lt;arg&gt; is any optional value that informs native execution of the query.
  for example if the native platform supports a templating scheme as in
  datalog</pre></div></div><div class="public anchor" id="var-read-only.3F"><h3>read-only?</h3><div class="usage"><code>(read-only? g)</code></div><div class="doc"><pre class="plaintext">Returns true if the membership of &lt;g&gt; is static 
and add/subtract functions will throw an exception. This 
may hold for example when &lt;g&gt; is a public endpoint for which write 
permission is denied</pre></div></div><div class="public anchor" id="var-subjects"><h3>subjects</h3><div class="usage"><code>(subjects g)</code></div><div class="doc"><pre class="plaintext">Returns (&lt;s&gt;...) for &lt;g&gt;
Where 
&lt;s&gt; is a subject in one or more triples in &lt;g&gt;
&lt;g&gt; is a graph.</pre></div></div><div class="public anchor" id="var-subtract"><h3>subtract</h3><div class="usage"><code>(subtract g to-subtract)</code></div><div class="doc"><pre class="plaintext">Returns &lt;g&gt; with &lt;to-subtract&gt; removed from its contents.
Throws an exception if (read-only? &lt;g&gt;)
Where
&lt;g&gt; is a graph
&lt;to-subtract&gt; is in some format interpretable as a set of triples.</pre></div></div></div></div></div><div class="public anchor" id="var-ISet"><h3>ISet</h3><h4 class="type">protocol</h4><div class="usage"></div><div class="doc"><pre class="plaintext">Basic set operations between graphs.
</pre></div><div class="members"><h4>members</h4><div class="inner"><div class="public anchor" id="var-difference"><h3>difference</h3><div class="usage"><code>(difference g1 g2)</code></div><div class="doc"><pre class="plaintext">Returns an IGraph whose normal form contains all statements in g1 not present in g2.
</pre></div></div><div class="public anchor" id="var-intersection"><h3>intersection</h3><div class="usage"><code>(intersection g1 g2)</code></div><div class="doc"><pre class="plaintext">Returns an IGraph whose normal form contains all and only statements shared by both g1 and g2
</pre></div></div><div class="public anchor" id="var-union"><h3>union</h3><div class="usage"><code>(union g1 g2)</code></div><div class="doc"><pre class="plaintext">Returns an IGraph whose normal form contains all triples from g1 and g2
</pre></div></div></div></div></div><div class="public anchor" id="var-match-or-traverse"><h3>match-or-traverse</h3><h4 class="type">multimethod</h4><div class="usage"></div><div class="doc"><pre class="plaintext">Returns values appropriate for (g s p) or (g s p o) invocations
Where
&lt;o&gt; is an object in &lt;g&gt;
&lt;s&gt; is a subject in &lt;g&gt;
&lt;p&gt; is either a predicate in &lt;g&gt; or a traversal function accumulating
  a set, starting with an empty accumulator and  queue of [&lt;s&gt;]
  (see docs for `traverse`)
NOTE: Implementers of IGraph will typically use this
  method for IFn `invoke` members involving a &lt;p&gt; argument.
</pre></div></div><div class="public anchor" id="var-normal-form.3F"><h3>normal-form?</h3><div class="usage"><code>(normal-form? m)</code></div><div class="doc"><pre class="plaintext">Returns true iff &lt;m&gt; is in normal form for IGraph.
</pre></div></div><div class="public anchor" id="var-p-dispatcher"><h3>p-dispatcher</h3><div class="usage"><code>(p-dispatcher g s p)</code><code>(p-dispatcher g s p o)</code></div><div class="doc"><pre class="plaintext">Returns :traverse or :match, as a basis for dispatching standard `invoke` methods involving a &lt;p&gt; argument, which may be either a value ot match or a traversal function.
</pre></div></div><div class="public anchor" id="var-remove-from-graph"><h3>remove-from-graph</h3><h4 class="type">multimethod</h4><div class="usage"></div><div class="doc"><pre class="plaintext">Returns &lt;g&gt;, with &lt;to-add&gt; added
Where
&lt;g&gt; is a Graph
&lt;to-add&gt; is interpetable as a set of triples
Dispatched according to `alter-graph-dispatcher`
</pre></div></div><div class="public anchor" id="var-transitive-closure"><h3>transitive-closure</h3><div class="usage"><code>(transitive-closure p)</code></div><div class="doc"><pre class="plaintext">Returns &lt;traversal&gt; for chains of `p`.
Where
&lt;traversal&gt; := (fn [g acc queue]...) -&gt; [&lt;acc'&gt; &lt;queue'&gt;], 
  s.t. &lt;queue'&gt; conj's all &lt;o&gt; s.t. (g &lt;s&gt; &lt;p&gt; &lt;o&gt;).  
  A traversal function argument for the `traverse` function .
&lt;p&gt; is a predicate, typcially an element of &lt;g&gt;
&lt;g&gt; is a graph.
  </pre></div></div><div class="public anchor" id="var-traverse"><h3>traverse</h3><div class="usage"><code>(traverse g traversal acc queue)</code><code>(traverse g traversal context acc queue)</code></div><div class="doc"><pre class="plaintext">Returns `acc` acquired by applying `traversal` to `g` starting with `queue`, informed by `context`
Where
&lt;acc&gt; is an arbitrary clojure 'accumulator' object (similar to a
  reduce function)
&lt;traversal&gt; := (fn [g context acc queue]...)
                -&gt; [&lt;context'&gt; &lt;acc'&gt; &lt;queue'&gt;]
&lt;g&gt; is a graph
&lt;context&gt; := {&lt;context-key&gt; &lt;context-value&gt;....}, expressing important
  aspects of the traversal state
&lt;queue&gt; := [&lt;node&gt; ...], nodes to visit
&lt;context-key&gt; := #{:history ... maybe :skip? ... :seek ... or other
  keys specific to &lt;traversal&gt;, which &lt;traversal&gt; may use to communicate
  with future iterations of itself.
&lt;history&gt; := #{&lt;visited-node&gt; ...}, this is conj'd with each visited node on
  each call to avoid cycles.
&lt;skip?&gt; (optional) := (fn [&lt;node&gt;] -&gt; true if we should skip). This may also
  be a set of nodes to skip. This allows for overriding the default skipping
  behavior which simply skips &lt;history&gt;
&lt;seek&gt; (optional) := (fn [context acc] -&gt; &lt;acc'&gt;, a function to be called
  at the start of each traversal, a truthy, non-empty response to which will
  be the immediate return value of the traverse function. This would save you
  the time and trouble of processing the whole queue, or making each traversal
  function smart enough to stop early. Must return the same type as &lt;acc&gt;.
&lt;node&gt; is typically an element in &lt;g&gt;, but can be any value the traversal
  function knows how to handle
&lt;visited-node&gt; is a node visited upstream. We filter these out to
  avoid cycles. This can also be specified in advance by the user.
&lt;target&gt; is a node we may be searching for.
Note: it is good practice to assign a :transition-fn metadata tag to
  transition functions, though such data is not referenced anywhere
  at this point.</pre></div></div><div class="public anchor" id="var-traverse-link"><h3>traverse-link</h3><div class="usage"><code>(traverse-link p)</code></div><div class="doc"><pre class="plaintext">Returns traversal function (fn [g context, acc queue]...)
  -&gt; [context, acc', queue'], following one &lt;p&gt; in &lt;g&gt;
Where
&lt;acc&gt; is a set
&lt;queue&gt; := [&lt;node&gt; ...], nodes to visit in traversal
&lt;p&gt; is a predicate in &lt;g&gt;
&lt;g&gt; is a graph

NOTE: typically used as one component in a traversal path</pre></div></div><div class="public anchor" id="var-unique"><h3>unique</h3><div class="usage"><code>(unique coll on-ambiguity)</code><code>(unique coll)</code></div><div class="doc"><pre class="plaintext">Returns the single member of &lt;coll&gt;, or nil if &lt;coll&gt; is empty. Calls &lt;on-ambiguity&gt; if there is more than one member (default is to throw an Exception).
Where
&lt;coll&gt; is a collection
&lt;on-ambiguity&gt; := (fn [coll] ...) -&gt; &lt;value&gt;, default raises an error.
Note: this can be used when you've called (G s p) and you're sure there is
  only one object.
</pre></div></div></div></body></html>