<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><title>Introduction to igraph</title><link rel="stylesheet" type="text/css" href="css/default.css" /><link rel="stylesheet" type="text/css" href="css/highlight.css" /><script type="text/javascript" src="js/highlight.min.js"></script><script type="text/javascript" src="js/jquery.min.js"></script><script type="text/javascript" src="js/page_effects.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html"><span class="project-title"><span class="project-name">Igraph</span> <span class="project-version">0.1.4-SNAPSHOT</span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Topics</span></h3><ul><li class="depth-1  current"><a href="intro.html"><div class="inner"><span>Introduction to igraph</span></div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>igraph</span></div></div></li><li class="depth-2 branch"><a href="igraph.core.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>core</span></div></a></li><li class="depth-2"><a href="igraph.graph.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>graph</span></div></a></li></ul></div><div class="document" id="content"><div class="doc"><div class="markdown"><h1><a href="#introduction-to-igraph" name="introduction-to-igraph"></a>Introduction to igraph</h1>
<h2><a href="#usage" name="usage"></a>Usage</h2>
<h3><a href="#igraph" name="igraph"></a>IGraph</h3>
<p>The <code>IGraph</code> protocol specifies the following functions:</p>
<h4><a href="#member-access" name="member-access"></a>Member access</h4>
<ul>
  <li><code>(normal-form g)</code> -&gt; {s {p #{o…}…}…}</li>
  <li><code>(subjects g)</code> -&gt; (s …), a collection of subjects</li>
  <li><code>(get-p-o g s)</code> -&gt; {p #{o…} …}</li>
  <li><code>(get-o g s p)</code> -&gt; #{o …}</li>
  <li><code>(ask g s p o)</code> -&gt; truthy</li>
  <li>
  <p><code>(query g q)</code> -&gt; collection of {var value …} maps</p>
  <h4><a href="#membership-changes" name="membership-changes"></a>Membership changes</h4></li>
  <li><code>(read-only? g)</code> -&gt; true if changing membership throws an exception</li>
  <li><code>(add g to-add)</code> -&gt; new graph with <i>to-add</i> present</li>
  <li><code>(subtract g to-subtract)</code> -&gt; new graph with <i>to-subtract</i> absent</li>
</ul>
<p>Also a corresponding <code>invoke</code> to support <code>IFn</code> as follows - <code>(g)</code> = <code>(normal-form g)</code> - <code>(g s)</code> -&gt; {p #{o…} …} - <code>(g s p)</code> -&gt; #{o …} - <code>(g s p o)</code> -&gt; truthy </p>
<h4><a href="#traversal" name="traversal"></a>Traversal</h4>
<p>There is a traversal regime based on a calling function called <code>traverse</code>:</p>
<ul>
  <li><code>(traverse g traversal context acc queue)</code> -&gt; <code>acc</code>
    <p>… traversing <code>g</code> per the <code>traversal</code> function, starting with the  first element of <code>queue</code>, possibly informed by <code>context</code>.</p>
  </li>
</ul>
<p>This function will repeatedly call <code>traversal</code>, consuming the head of <code>queue</code>, aggregating into the accumulator <code>acc</code>, with each iteration, returning <code>acc</code> when <code>queue</code> is empty. Each execution of the traversal function should return an altered <code>queue</code>. This may just be the tail of the previous queue, but could also be for example reordered and truncated to define a beam search. Appending to the queue would implement a breadth-first search; prepending would implement a depth-first search.</p>
<p>The <code>context</code> argument is a map containing key-values which may inform the course of the traversal. These may include:</p>
<ul>
  <li><code>:history</code> this will be set by <code>traverse</code>, and updated to hold all  elements encountered in the course of the traversal. In order to  avoid cycles, any element in the history will be skipped should it  ever re-appear at the head of the queue.</li>
  <li><code>:skip?</code> (optional) a function (fn[x] …) -&gt; truthy (or a set)  which will override <code>:history</code>, specifiable at initialization or by  the traversal function during execution.</li>
  <li><code>:seek</code> (optional) a function (fn [context acc]…) -&gt; &lt;acc’&gt;. If  specified, this function will be called at the beginning of each  traversal, and if truthy and non-empty the traversal will end  immediately with that value. If specified and the queue is empty,  the output of this function will be the value of the function.</li>
</ul>
<h5><a href="#traversal-functions" name="traversal-functions"></a>Traversal functions</h5>
<p>A <code>traversal function</code> has the signature (fn [g context acc queue]…) -&gt; [context’ acc’ queue’].</p>
<p>The <code>context</code> argument can contain key/values specific to the traversal function can also be specified at initialization or as the output of the traversal function itself. This might for example be data that guides some kind of beam-search.</p>
<ul>
  <li><code>(trasitive-closure p)</code> -&gt; (fn [g context acc to-visit] …) -&gt; [context’ acc’ queue’],  a traversal argument to <code>traverse</code>.</li>
</ul>
<h6><a href="#as-the-argument-in-accessors" name="as-the-argument-in-accessors"></a>As the <code>p</code> argument in accessors</h6>
<p>Recall that implementations of IGraph should provide <code>invoke</code> functions with 0-3 arguments.</p>
<p>Two of these functions involve specification of a <code>p</code> parameter:</p>
<pre><code>(g s p) -&gt; {&lt;o&gt;...}
(g s p o) -&gt; truthy.
</code></pre>
<p><code>(match-or-traverse g s p)</code> -&gt; #{<o>…} <code>(match-or-traverse g s p o)</code> -&gt; truthy</o></p>
<p>IGraph defines a multi-method <code>match-or-traverse</code> dispatched on the output of `(p-dipatcher p) -&gt; :match | :traverse.</p>
<p>The <code>:match</code> method should simply imply the corresponding “get” function above, <code>:traverse</code> method will expect <code>p</code> to be a traversal function whose <code>acc</code> is a set of graph elements.</p>
<p>Thus implementations of IGraph would typically define <code>invoke</code> involving <code>p</code> arguments using <code>match-or-traverse</code>.</p>
<p>See also the examples in the <code>Graph</code> section below.</p>
<h4><a href="#multimethods-to-add-remove-from-graph" name="multimethods-to-add-remove-from-graph"></a>Multimethods to add/remove from graph</h4>
<p>There are multi-methods defined <code>add-to-graph</code> and <code>remove-from-graph</code>, dispatched on <code>alter-graph-dispatcher</code></p>
<pre><code>(alter-graph-dispatcher g to-add-or-remove)
-&gt; 
One of :normal-form, :vector, :vector-of-vectors, or the type of `to-add-or-remove`
</code></pre>
<p>Implementations of IGraph will typically define methods for each of these values when defining <code>add</code> and <code>subtract</code>.</p>
<h4><a href="#utilities" name="utilities"></a>utilities</h4>
<ul>
  <li><code>(normal-form? m)</code> -&gt; true iff m is a map in normal form.</li>
</ul>
<p>The <a href="https://github.com/ont-app/igraph/blob/master/src/igraph/core.clj">source file</a> has fairly explicit docstrings.</p>
<h3><a href="#iset" name="iset"></a>ISet</h3>
<p>It may make sense for some implementations of IGraph also to implement the basic set operations, defined in ISet:</p>
<ul>
  <li><code>(union g1 12)</code> -&gt; A new graph with all triples from both graphs</li>
  <li><code>(difference g1 g2)</code> -&gt; A new graph with triples in g1 not also in g2</li>
  <li><code>(intersection g1 g2)</code> -&gt; A new graph with only triples shared in both graphs</li>
</ul>
<h2><a href="#graph" name="graph"></a>Graph</h2>
<p>The Graph type is a very lightweight implementation of IGraph. The aim here, aside from demonstrating IGraph, is to add just one layer of expressiveness over the <code>map</code> construct.</p>
<p>To create:</p>
<pre><code>(make-graph)
-&gt; 
#object[igraph.graph.Graph 0x67e46c69 "igraph.graph.Graph@67e46c69"]
</code></pre>
<p>One adds to it like this (returns a new immutable object):</p>
<pre><code>(add my-graph
  [[:john :isa :person]
   [:john :likes :meat]
   [:john :name {:value "John" :lang "en"}]
   [:mary
    :isa :person
    :likes :coke
    :name {:value "Mary" :lang "en"}
    ]
   [:likes :isa :property]
   [:isa :isa :property]
   [:meat :isa :food]
   [:coke :isa :drink]
   [:drink :subClassOf :consumable]
   [:food :subClassOf :consumable]
   [:consumable :subClassOf :thing]
   [:person :subClassOf :thing]
  ])))
-&gt;
#object[igraph.graph.Graph 0x58b96f62 "igraph.graph.Graph@58b96f62"]
</code></pre>
<p>The <code>subjects</code> function will give you the subjects:</p>
<pre><code>(subjects my-graph)
-&gt; 
(:john :mary :likes :isa :meat :coke :drink :food :consumable :person)
</code></pre>
<p>Invoked without arguments gives you <code>normal form</code>:</p>
<pre><code>(pprint (my-graph))
-&gt;
{:consumable {:subClassOf #{:thing}},
 :person {:subClassOf #{:thing}},
 :isa {:isa #{:property}},
 :drink {:subClassOf #{:consumable}},
 :likes {:isa #{:property}},
 :coke {:isa #{:drink}},
 :meat {:isa #{:food}},
 :food {:subClassOf #{:consumable}},
 :john
 {:isa #{:person},
  :likes #{:meat},
  :name #{{:value "John", :lang "en"}}},
 :mary
 {:isa #{:person},
  :likes #{:coke},
  :name #{{:value "Mary", :lang "en"}}}}

</code></pre>
<p>Invoked with a subject gives you its predicate-object map:</p>
<pre><code>(my-graph :john)
-&gt;
{:isa #{:person}, 
 :likes #{:meat}, 
 :name #{{:value "John", :lang "en"}}}
</code></pre>
<p>Invoked with a subject and predicate gives you the set of objects:</p>
<pre><code>(my-graph :john :likes)
-&gt;
#{:meat}
</code></pre>
<p>Traversal is done with a function that returns the accumulator and a possibly empty list of nodes in the graph still to visit…</p>
<pre><code>(def g (add (make-graph) [[:a :subClassOf :b] 
                          [:b :subClassOf :c]
                          [:c :subClassOf :d]]))

(defn subClassOf* [g context acc to-visit]
   [context,
    (conj acc (first to-visit)),
    (concat (rest to-visit) (g (first to-visit) :isa))])
   
(traverse g subClassOf* [] [:a])
-&gt;
[:a :b :c :d]
</code></pre>
<p>The subClassOf* function defined above is equivalent to <code>transitive-closure</code>:</p>
<pre><code>(traverse g (transitive-closure :subClassOf) [] [:a])
-&gt;
[:a :b :c :d]
</code></pre>
<p>A graph can be invoked with a subject and a traversal function as its <code>p</code> argument, which will give you the result of the traversal with a starting queue of [s]:</p>
<pre><code>(def subClassOf* (transitive-closure :subClassOf))

(my-graph :drink subClassOf*)
-&gt; 
#{:consumable :drink :thing}

</code></pre>
<p>If you’re sure there’s only going to be one object you can use the <code>unique</code> function:</p>
<pre><code>(unique (my-graph :john :likes))
-&gt;
:meat

(unique #{:just-me :no-theres-me-too!})
-&gt; 
Exception Non-unique: #{:no-theres-me-too! :just-me}

</code></pre>
<p>Invoked with subject, predicate and object gives you the object (if its there):</p>
<pre><code>(my-graph :john :likes :meat)
-&gt;
:meat
</code></pre>
<p>Or with with a traversal function:</p>
<pre><code>(my-graph :drink subClassOf* :thing)
;; -&gt;
:thing
</code></pre>
<p>Querying is done with a very simple graph pattern using keywords starting with ?:</p>
<pre><code>(query my-graph
    [[:?liker :likes :?likee]
     [:?likee :isa :?type]])
-&gt; 
#{{:?type :drink, :?likee :coke, :?liker :mary}
  {:?type :food, :?likee :meat, :?liker :john}}
</code></pre>
<p>We can also use traversal functions for the p argument:</p>
<pre><code>(query my-graph
  [[:?liker :likes :?likee]
   [:?likee :isa :?class]
   [:?class subClassOf* :?super]])
-&gt;
#{{:?super :thing, :?class :food, :?likee :meat, :?liker :john}
  {:?super :thing, :?class :drink, :?likee :coke, :?liker :mary}
  {:?super :food, :?class :food, :?likee :meat, :?liker :john}
  {:?super :consumable, :?class :drink, :?likee :coke, :?liker :mary}
  {:?super :consumable, :?class :food, :?likee :meat, :?liker :john}
  {:?super :drink, :?class :drink, :?likee :coke, :?liker :mary}}
</code></pre>
<p>One subtracts from it like this (also returns new immutable object):</p>
<pre><code>(normal-form 
  (subtract 
    (add (make-graph) 
         [[:a :b :c :d :e] [:g :h :i]])
    [:a]))
;; -&gt; 
;; {:g {:h #{:i}}}

(normal-form 
  (subtract 
    (add (make-graph) 
         [[:a :b :c :d :e] [:g :h :i]])
    [:a :b]))
;; -&gt;
;; {:a {:d #{:e}}, :g {:h #{:i}}}

(normal-form 
  (subtract 
    (add (make-graph) 
         [[:a :b :c :d :e] [:g :h :i]])
    [:a :b :c]))
;; -&gt;
;; {:a {:d #{:e}}, :g {:h #{:i}}}

(normal-form 
  (subtract 
    (add (make-graph) 
         [[:a :b :c :d :e] [:g :h :i]])
    [[:a :b][:g :h :i]]))
;; -&gt;
;; {:a {:d #{:e}}}

</code></pre>
<p>Graph also implements the <code>ISet</code> functions <code>union</code>, <code>difference</code> and <code>intersection</code>.</p></div></div></div></body></html>