<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><title>ont-app.igraph.core documentation</title><link rel="stylesheet" type="text/css" href="css/default.css" /><link rel="stylesheet" type="text/css" href="css/highlight.css" /><script type="text/javascript" src="js/highlight.min.js"></script><script type="text/javascript" src="js/jquery.min.js"></script><script type="text/javascript" src="js/page_effects.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html"><span class="project-title"><span class="project-name">Igraph</span> <span class="project-version">0.1.6-SNAPSHOT</span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>ont-app</span></div></div></li><li class="depth-2"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>igraph</span></div></div></li><li class="depth-3 branch current"><a href="ont-app.igraph.core.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>core</span></div></a></li><li class="depth-3 branch"><a href="ont-app.igraph.core-test.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>core-test</span></div></a></li><li class="depth-3 branch"><a href="ont-app.igraph.graph.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>graph</span></div></a></li><li class="depth-3"><a href="ont-app.igraph.graph-test.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>graph-test</span></div></a></li></ul></div><div class="sidebar secondary"><h3><a href="#top"><span class="inner">Public Vars</span></a></h3><ul><li class="depth-1"><a href="ont-app.igraph.core.html#var-add-to-graph"><div class="inner"><span>add-to-graph</span></div></a></li><li class="depth-1"><a href="ont-app.igraph.core.html#var-assert-unique"><div class="inner"><span>assert-unique</span></div></a></li><li class="depth-1"><a href="ont-app.igraph.core.html#var-flatten-description"><div class="inner"><span>flatten-description</span></div></a></li><li class="depth-1"><a href="ont-app.igraph.core.html#var-IGraph"><div class="inner"><span>IGraph</span></div></a></li><li class="depth-2 branch"><a href="ont-app.igraph.core.html#var-ask"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>ask</span></div></a></li><li class="depth-2 branch"><a href="ont-app.igraph.core.html#var-get-o"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>get-o</span></div></a></li><li class="depth-2 branch"><a href="ont-app.igraph.core.html#var-get-p-o"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>get-p-o</span></div></a></li><li class="depth-2 branch"><a href="ont-app.igraph.core.html#var-invoke"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>invoke</span></div></a></li><li class="depth-2 branch"><a href="ont-app.igraph.core.html#var-mutability"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>mutability</span></div></a></li><li class="depth-2 branch"><a href="ont-app.igraph.core.html#var-normal-form"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>normal-form</span></div></a></li><li class="depth-2 branch"><a href="ont-app.igraph.core.html#var-query"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>query</span></div></a></li><li class="depth-2"><a href="ont-app.igraph.core.html#var-subjects"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>subjects</span></div></a></li><li class="depth-1"><a href="ont-app.igraph.core.html#var-IGraphAccumulateOnly"><div class="inner"><span>IGraphAccumulateOnly</span></div></a></li><li class="depth-2 branch"><a href="ont-app.igraph.core.html#var-claim"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>claim</span></div></a></li><li class="depth-2"><a href="ont-app.igraph.core.html#var-retract"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>retract</span></div></a></li><li class="depth-1"><a href="ont-app.igraph.core.html#var-IGraphImmutable"><div class="inner"><span>IGraphImmutable</span></div></a></li><li class="depth-2 branch"><a href="ont-app.igraph.core.html#var-add"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>add</span></div></a></li><li class="depth-2"><a href="ont-app.igraph.core.html#var-subtract"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>subtract</span></div></a></li><li class="depth-1"><a href="ont-app.igraph.core.html#var-IGraphMutable"><div class="inner"><span>IGraphMutable</span></div></a></li><li class="depth-2 branch"><a href="ont-app.igraph.core.html#var-add.21"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>add!</span></div></a></li><li class="depth-2"><a href="ont-app.igraph.core.html#var-subtract.21"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>subtract!</span></div></a></li><li class="depth-1"><a href="ont-app.igraph.core.html#var-IGraphSet"><div class="inner"><span>IGraphSet</span></div></a></li><li class="depth-2 branch"><a href="ont-app.igraph.core.html#var-difference"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>difference</span></div></a></li><li class="depth-2 branch"><a href="ont-app.igraph.core.html#var-intersection"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>intersection</span></div></a></li><li class="depth-2"><a href="ont-app.igraph.core.html#var-union"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>union</span></div></a></li><li class="depth-1"><a href="ont-app.igraph.core.html#var-match-or-traverse"><div class="inner"><span>match-or-traverse</span></div></a></li><li class="depth-1"><a href="ont-app.igraph.core.html#var-maybe-traverse-link"><div class="inner"><span>maybe-traverse-link</span></div></a></li><li class="depth-1"><a href="ont-app.igraph.core.html#var-normal-form.3F"><div class="inner"><span>normal-form?</span></div></a></li><li class="depth-1"><a href="ont-app.igraph.core.html#var-normalize-flat-description"><div class="inner"><span>normalize-flat-description</span></div></a></li><li class="depth-1"><a href="ont-app.igraph.core.html#var-p-dispatcher"><div class="inner"><span>p-dispatcher</span></div></a></li><li class="depth-1"><a href="ont-app.igraph.core.html#var-read-from-file"><div class="inner"><span>read-from-file</span></div></a></li><li class="depth-1"><a href="ont-app.igraph.core.html#var-reduce-spo"><div class="inner"><span>reduce-spo</span></div></a></li><li class="depth-1"><a href="ont-app.igraph.core.html#var-remove-from-graph"><div class="inner"><span>remove-from-graph</span></div></a></li><li class="depth-1"><a href="ont-app.igraph.core.html#var-t-comp"><div class="inner"><span>t-comp</span></div></a></li><li class="depth-1"><a href="ont-app.igraph.core.html#var-transitive-closure"><div class="inner"><span>transitive-closure</span></div></a></li><li class="depth-1"><a href="ont-app.igraph.core.html#var-traverse"><div class="inner"><span>traverse</span></div></a></li><li class="depth-1"><a href="ont-app.igraph.core.html#var-traverse-link"><div class="inner"><span>traverse-link</span></div></a></li><li class="depth-1"><a href="ont-app.igraph.core.html#var-traverse-or"><div class="inner"><span>traverse-or</span></div></a></li><li class="depth-1"><a href="ont-app.igraph.core.html#var-triples-format"><div class="inner"><span>triples-format</span></div></a></li><li class="depth-1"><a href="ont-app.igraph.core.html#var-triples-removal-format"><div class="inner"><span>triples-removal-format</span></div></a></li><li class="depth-1"><a href="ont-app.igraph.core.html#var-unique"><div class="inner"><span>unique</span></div></a></li><li class="depth-1"><a href="ont-app.igraph.core.html#var-write-to-file"><div class="inner"><span>write-to-file</span></div></a></li></ul></div><div class="namespace-docs" id="content"><h1 class="anchor" id="top">ont-app.igraph.core</h1><div class="doc"><pre class="plaintext">Abstractions over a graph object, intended to sit alongside the 
other basic clojure data structures such as maps, vectors and sets.</pre></div><div class="public anchor" id="var-add-to-graph"><h3>add-to-graph</h3><h4 class="type">multimethod</h4><div class="usage"></div><div class="doc"><pre class="plaintext">Returns `g`, with `to-add` added
Where
-   `g` is a Graph
-   `to-add` is interpetable as a set of triples
     Dispatched according to `triples-format`
</pre></div></div><div class="public anchor" id="var-assert-unique"><h3>assert-unique</h3><div class="usage"><code>(assert-unique g s p o)</code></div><div class="doc"><pre class="plaintext">Returns `g`', replacing any existing [s p *] with [s p o]
</pre></div></div><div class="public anchor" id="var-flatten-description"><h3>flatten-description</h3><div class="usage"><code>(flatten-description p-o)</code></div><div class="doc"><pre class="plaintext">Returns `p-o` description with singletons broken out into scalars
Where
  - `p-o` := {`p` #{`o`}, ...}, normal form at 'description' level of a graph.</pre></div></div><div class="public anchor" id="var-IGraph"><h3>IGraph</h3><h4 class="type">protocol</h4><div class="usage"></div><div class="doc"><pre class="plaintext">An abstraction for S-P-O graphs
</pre></div><div class="members"><h4>members</h4><div class="inner"><div class="public anchor" id="var-ask"><h3>ask</h3><div class="usage"><code>(ask g s p o)</code></div><div class="doc"><pre class="plaintext">Returns truthy value iff [`s` `p` `o`] appears in `g`
Where
- `g` is a graph
- `s` is subject of some triples in `g`
- `p` is predicate of some triples in `g`
- `o` appears in triple [`s` `p` `o`] in `g`</pre></div></div><div class="public anchor" id="var-get-o"><h3>get-o</h3><div class="usage"><code>(get-o g s p)</code></div><div class="doc"><pre class="plaintext">Returns {`o` ...} for `s` and `p` in `g`, or nil.
Where
- `g` is a graph
- `s` is subject of some triples in `g`
- `p` is predicate of some triples in `g`
- `o` appears in triple [`s` `p` `o`] in `g`</pre></div></div><div class="public anchor" id="var-get-p-o"><h3>get-p-o</h3><div class="usage"><code>(get-p-o g s)</code></div><div class="doc"><pre class="plaintext">Returns {`p` #{`o` ...}} associated with `s` in `g`, or nil.
Where
- `g` is a graph
- `s` is subject 
- `p` and `o` are in triples := [`s` `p` `o`] in `g`</pre></div></div><div class="public anchor" id="var-invoke"><h3>invoke</h3><div class="usage"><code>(invoke g)</code><code>(invoke g s)</code><code>(invoke g s p)</code><code>(invoke g s p o)</code></div><div class="doc"><pre class="plaintext">Applies `g` as a function to the rest of its arguments, representing 
   triples [`s` `p` `o`] in `g` respectively. `p` may optionally be 
   a traversal function (See `traverse` docs)
- (g) -&gt; {`s` {`p` #{`o`...}...}...} ;; = (normal-form `g`)
- (g s) -&gt; {`p` #{`o`...}, ...} ;; = (get-p-o `g`)
- (g s p) -&gt; #{`o` ...} ;; = (match-or-traverse g s p)
- (g s p o) -&gt; `o` iff [`s` `p` `o`] is in `g` ;; = (match-or-traverse g s p o)</pre></div></div><div class="public anchor" id="var-mutability"><h3>mutability</h3><div class="usage"><code>(mutability g)</code></div><div class="doc"><pre class="plaintext">Returns one of ::read-only ::immutable ::mutable ::accumulate-only
</pre></div></div><div class="public anchor" id="var-normal-form"><h3>normal-form</h3><div class="usage"><code>(normal-form g)</code></div><div class="doc"><pre class="plaintext">Returns {`s` {`p` #{`o`...}...}...}
Where 
- `s` is the subject of a triple := [`s` `p` `o`] in `g`
- `p` is predicate of same
- `o` is the object of same</pre></div></div><div class="public anchor" id="var-query"><h3>query</h3><div class="usage"><code>(query g q)</code></div><div class="doc"><pre class="plaintext">Returns #{`binding` ...} for query spec `q` applied to `g`
Where
- `binding` := {`var` `value`, ...}
- `q` is a query specification suitable for the native format of `g`
- `g` is a graph
- `args` := [`arg`....]
- `var` is a variable specified in `q`
- `value` is a value found in `g` bounded to `var` per `q`
- `arg` is any optional value that informs native execution of the query.
   for example if the native platform supports a templating scheme as in
   datalog</pre></div></div><div class="public anchor" id="var-subjects"><h3>subjects</h3><div class="usage"><code>(subjects g)</code></div><div class="doc"><pre class="plaintext">Returns (`s`...) for `g`
Where 
- `s` is a subject in one or more triples in `g`
- `g` is a graph.</pre></div></div></div></div></div><div class="public anchor" id="var-IGraphAccumulateOnly"><h3>IGraphAccumulateOnly</h3><h4 class="type">protocol</h4><div class="usage"></div><div class="doc"><pre class="plaintext"></pre></div><div class="members"><h4>members</h4><div class="inner"><div class="public anchor" id="var-claim"><h3>claim</h3><div class="usage"><code>(claim g to-add)</code></div><div class="doc"><pre class="plaintext">Returns `g`, with `to-add` added to `g`'s associated transactor.
Throws an exception if (mutability g) != ::accumulate-only
Where
- `g` is a mutable graph
- `to-add` is in triples-format
NOTE: see Datomic documentation for the 'add' operation for details</pre></div></div><div class="public anchor" id="var-retract"><h3>retract</h3><div class="usage"><code>(retract g to-retract)</code></div><div class="doc"><pre class="plaintext">Returns `g` with `comm` reset to head
Side-effect:  `to-retract` retracted from `comm`
Throws an exception if (mutability g) != ::accumulate-only.
Where
- `g` is a graph
- `comm` is a datomic-style transactor
`to-retract` is in triples-removal-format
NOTE: see Datomic documentation for details</pre></div></div></div></div></div><div class="public anchor" id="var-IGraphImmutable"><h3>IGraphImmutable</h3><h4 class="type">protocol</h4><div class="usage"></div><div class="doc"><pre class="plaintext"></pre></div><div class="members"><h4>members</h4><div class="inner"><div class="public anchor" id="var-add"><h3>add</h3><div class="usage"><code>(add g to-add)</code></div><div class="doc"><pre class="plaintext">Returns `g`', with `to-add` added to its contents.
Throws a ::ReadOnly exception if (read-only? `g`)
Where
- `g` is a graph
- `to-add` is in triples-format</pre></div></div><div class="public anchor" id="var-subtract"><h3>subtract</h3><div class="usage"><code>(subtract g to-subtract)</code></div><div class="doc"><pre class="plaintext">Returns `g`' with `to-subtract` removed from its contents.
Throws an exception if (mutability g) != ::immutable
Where
- `g` is an immutablegraph
- `to-subtract` is in triples-removal-format</pre></div></div></div></div></div><div class="public anchor" id="var-IGraphMutable"><h3>IGraphMutable</h3><h4 class="type">protocol</h4><div class="usage"></div><div class="doc"><pre class="plaintext"></pre></div><div class="members"><h4>members</h4><div class="inner"><div class="public anchor" id="var-add.21"><h3>add!</h3><div class="usage"><code>(add! g to-add)</code></div><div class="doc"><pre class="plaintext">Returns `g`, with `to-add` added to its contents.
Throws an exception if (mutability g) != ::mutable
Where
- `g` is a mutable graph
- `to-add` is in triples-format</pre></div></div><div class="public anchor" id="var-subtract.21"><h3>subtract!</h3><div class="usage"><code>(subtract! g to-subtract)</code></div><div class="doc"><pre class="plaintext">Returns `g` with `to-subtract` removed from its contents.
Throws a ::ReadOnly exception if (read-only? `g`)
Where
- `g` is a graph
- `to-subtract` is in triples-removal-format</pre></div></div></div></div></div><div class="public anchor" id="var-IGraphSet"><h3>IGraphSet</h3><h4 class="type">protocol</h4><div class="usage"></div><div class="doc"><pre class="plaintext">Basic set operations between graphs.
</pre></div><div class="members"><h4>members</h4><div class="inner"><div class="public anchor" id="var-difference"><h3>difference</h3><div class="usage"><code>(difference g1 g2)</code></div><div class="doc"><pre class="plaintext">Returns an IGraph whose normal form contains all statements in g1 not present in g2.
</pre></div></div><div class="public anchor" id="var-intersection"><h3>intersection</h3><div class="usage"><code>(intersection g1 g2)</code></div><div class="doc"><pre class="plaintext">Returns an IGraph whose normal form contains all and only statements shared by both g1 and g2
</pre></div></div><div class="public anchor" id="var-union"><h3>union</h3><div class="usage"><code>(union g1 g2)</code></div><div class="doc"><pre class="plaintext">Returns an IGraph whose normal form contains all triples from g1 and g2
</pre></div></div></div></div></div><div class="public anchor" id="var-match-or-traverse"><h3>match-or-traverse</h3><h4 class="type">multimethod</h4><div class="usage"></div><div class="doc"><pre class="plaintext">Returns values appropriate for (g s p) or (g s p o) invocations
Where
-   `o` is an object in `g`
-   `s` is a subject in `g`
-   `p` is either a predicate in `g` or a traversal function accumulating
    a set, starting with an empty accumulator and  queue of [`s`]
    (see docs for `traverse`)
NOTE: Implementers of IGraph will typically use this
  method for IFn `invoke` members involving a `p` argument.
</pre></div></div><div class="public anchor" id="var-maybe-traverse-link"><h3>maybe-traverse-link</h3><div class="usage"><code>(maybe-traverse-link p)</code></div><div class="doc"><pre class="plaintext">Returns traversal function (fn [g context, acc queue]...)
  -&gt; [context, acc', queue'], 
Where
-   `acc'` includes `node` and and as many `o`s as are linked from `node`
     by `p` in `g` 
- `queue` := [`node` ...], nodes to visit in traversal
-   `p` is a predicate in `g`
-   `g` is a graph

NOTE: typically used as one component in a traversal path. 
cf the '?' operator in SPARQL property paths</pre></div></div><div class="public anchor" id="var-normal-form.3F"><h3>normal-form?</h3><div class="usage"><code>(normal-form? m)</code></div><div class="doc"><pre class="plaintext">Returns true iff `m` is in normal form for IGraph.
</pre></div></div><div class="public anchor" id="var-normalize-flat-description"><h3>normalize-flat-description</h3><div class="usage"><code>(normalize-flat-description m)</code></div><div class="doc"><pre class="plaintext">Returns a normalized p-o description of `m`
Where
-   `m` is a plain clojure map</pre></div></div><div class="public anchor" id="var-p-dispatcher"><h3>p-dispatcher</h3><div class="usage"><code>(p-dispatcher g s p)</code><code>(p-dispatcher g s p o)</code></div><div class="doc"><pre class="plaintext">Returns :traverse or :match, as a basis for dispatching standard `invoke` methods involving a `p` argument, which may be either a value ot match or a traversal function.
</pre></div></div><div class="public anchor" id="var-read-from-file"><h3>read-from-file</h3><div class="usage"><code>(read-from-file g path)</code></div><div class="doc"><pre class="plaintext">returns `g` with the contents of `path` added
Where
  - `g` implements IGraph
  - `path` is an edn file containing a normal-form representation of some graph,
     typically the output of save-to-file.</pre></div></div><div class="public anchor" id="var-reduce-spo"><h3>reduce-spo</h3><div class="usage"><code>(reduce-spo f acc g)</code></div><div class="doc"><pre class="plaintext">Returns `acc'` s.t. (f acc s p o) -&gt; `acc'` for every triple in `g`
Where
  - `f` := (fn [acc s p o] -&gt; `acc'`
  - `acc` is any value, a reduction accumlator
  - `s` `p` `o` constitute a triple in `g`
  - `g` implements IGraph
NOTE: C.f. reduce-kv</pre></div></div><div class="public anchor" id="var-remove-from-graph"><h3>remove-from-graph</h3><h4 class="type">multimethod</h4><div class="usage"></div><div class="doc"><pre class="plaintext">Returns `g`, with `to-remove` removed
Where
-   `g` is a Graph
-   `to-add` is interpetable as a set of triples
Dispatched according to `triples-removal-format`
</pre></div></div><div class="public anchor" id="var-t-comp"><h3>t-comp</h3><div class="usage"><code>(t-comp comp-spec)</code></div><div class="doc"><pre class="plaintext">Returns a traversal function composed of elements specified in `comp-spec`
Where
  - `comp-spec` := {:path [`spec-element`, ...]
                   `spec-element` {:fn `traversal-fn`
                                  :doc `docstring`
                                  :into `initial-acc` (default [])
                                  :local-context-fn `local-fn` (default nil)
                                  :update-global-context `global-fn` ( default nil)
                               }
                }
  - `spec-element` is typically a keyword naming a stage in the traversal, though
    it can also be a direct reference to a traversal function, in which case
    it will be equivalent to {:fn `spec-element`}
  - `traversal-fn-generator` := (fn [spec-element]...) -&gt; `traversal-fn`, to be 
    invoked in cases where there is no `spec-element` in `comp-spec`,
    traverse-link is the typical choice here.
  - `traversal-fn` := (fn [g context acc queue]...) -&gt; [context' acc' queue']
  - `context` is a traversal context conforming to the traverse function (see docs)
  - `update-fn` := (fn [global-context local-context] ...) -&gt; global-context' 
    This is provided in case there is some coordination that needs to be provided
    between stages in a composed traversal.
  - `initial-acc` is the (usually empty) container used to initial the acc
    of the traversal stage being specified
  - `local-context-fn` := [global-context] -&gt; `local-context`
  - `update-global-context` := [global-context local-context] -&gt; `global-context`'
  - `local-context` is the context for a given stage of the traversal
  - `global-context` carries over between traversal stages.
Examples 
(def comp-spec  {
                    :isa? {:fn (maybe-traverse-link :isa)
                          :doc `traverses an isa link, if it exists`
                          :local-context {:doc `traversing an isa link`}
                          :update-global-context 
                          (fn [gc lc] (assoc gc 
                                             :status :followed-isa-link))
                         }
                    :subClassOf* {:fn (transitive-closure :subClassOf)
                                  :doc 'traverses 0 or more subClassof links'
                                  :local-context-fn (fn [c] {:doc 'traversing subClassOf*'})
                                  :into #{}
                                  :update-global-context
                                  (fn [gc lc] (assoc gc 
                                               :status :followed-subclassof))
                                  }
                     }})
(traversal-comp (merge comp-spec
                      {:path [:isa? :subClassOf*]
                       :doc 'Traverses the chain of subsumption links for an instance or class'
                      }))

(t-comp (merge comp-spec {:path [:isa :label] :doc 'gets class labels')))
  
Short form example:

(t-comp [:family/parent :family/brother])
  ... Equal to (t-comp [(traverse-link :family/parent)
                        (traverse-link :family/brother)]
An inferred 'uncle' relation.</pre></div></div><div class="public anchor" id="var-transitive-closure"><h3>transitive-closure</h3><div class="usage"><code>(transitive-closure p)</code></div><div class="doc"><pre class="plaintext">Returns `traversal` for chains of `p`.
Where
`traversal` := (fn [g acc queue]...) -&gt; [`context` `acc'` `queue'`], 
  s.t. `queue'` conj's all `o` s.t. (g `s` `p` `o`).  
  A traversal function argument for the `traverse` function .
`p` is a predicate, typcially an element of `g`
`g` is a graph.
NOTE:
cf the '*' operator in SPARQL property paths
</pre></div></div><div class="public anchor" id="var-traverse"><h3>traverse</h3><div class="usage"><code>(traverse g traversal acc queue)</code><code>(traverse g traversal context acc queue)</code></div><div class="doc"><pre class="plaintext">Returns `acc` acquired by applying `traversal` to `g` starting with `queue`, informed by `context`
Where
-   `acc` is an arbitrary clojure 'accumulator' object (similar to a
    reduce function)
-   `traversal` := (fn [g context acc queue]...)
                   -&gt; [`context'` `acc'` `queue'`]
-   `g` is a graph
-   `context` := {`context-key` `context-value`....}, expressing important
    aspects of the traversal state
-   `queue` := [`node` ...], nodes to visit
-   `context-key` := #{:history ... maybe :skip? ... :seek ... or other
     keys specific to `traversal`, which `traversal` may use to communicate
     with future iterations of itself.
-   `history` := #{`visited-node` ...}, this is conj'd with each visited node on
     each call to avoid cycles.
-   `skip?` (optional) := (fn [`node`] -&gt; true if we should skip). This may also
     be a set of nodes to skip. This allows for overriding the default skipping
     behavior which simply skips `history`
-   `seek` (optional) := (fn [context acc] -&gt; `acc'`, a function to be called
    at the start of each traversal, a truthy, non-empty response to which will
    be the immediate return value of the traverse function. This would save you
    the time and trouble of processing the whole queue, or making each traversal
    function smart enough to stop early. Must return the same type as `acc`.
-   `node` is typically an element in `g`, but can be any value the traversal
    function knows how to handle
-   `visited-node` is a node visited upstream. We filter these out to
    avoid cycles. This can also be specified in advance by the user.
-   `target` is a node we may be searching for.
Note: it is good practice to assign a :transition-fn metadata tag to
  transition functions, though such data is not referenced anywhere
  at this point.</pre></div></div><div class="public anchor" id="var-traverse-link"><h3>traverse-link</h3><div class="usage"><code>(traverse-link p)</code></div><div class="doc"><pre class="plaintext">Returns traversal function (fn [g context, acc queue]...)
  -&gt; [context, acc', queue'], following one `p` in `g`
Where
-   `acc` is a set
-   `queue` := [`node` ...], nodes to visit in traversal
-   `p` is a predicate in `g`
-   `g` is a graph

NOTE: typically used as one component in a traversal path</pre></div></div><div class="public anchor" id="var-traverse-or"><h3>traverse-or</h3><div class="usage"><code>(traverse-or &amp; ps)</code></div><div class="doc"><pre class="plaintext">Returns traversal function (fn [g context, acc queue]...)
  -&gt; [context, acc', queue'], for `ps`
Where
-   `acc'` includes `node` and and as many `o`s as are linked from `node`
     by `p1` | `p2` | ...  in `g` 
- `queue` := [`node` ...], nodes to visit in traversal
-   `ps` := [`p1`, `p2`, ...]
-   `p1`, `p2`, ...  are all predicates in `g`, or traversal functions
-   `g` is a graph

cf the '|' operator in SPARQL property paths</pre></div></div><div class="public anchor" id="var-triples-format"><h3>triples-format</h3><div class="usage"><code>(triples-format triples-spec)</code></div><div class="doc"><pre class="plaintext">Returns the value of (:triples-format (meta `triples-spec`)) or one of #{:vector :vector-of-vectors :normal-form `type`} inferred from the shape of `triples-spec`
Where
-   `args` := [`g` `triples-spec`],  arguments to a method add or remove from graph
-   `g` is a graph
-   `triples-spec` is a specification of triples typically to add to or remove
    from  `g`
-   `:normal-form` indicates (normal-form? `triples-spec`) = true
-   `:triple` indicates `triples-spec` := [`s` `p` `o`]
-   `:vector-of-vectors` indicates `triples-spec` := [`triple`...]
-   `type` = (type `triples-spec`)
</pre></div></div><div class="public anchor" id="var-triples-removal-format"><h3>triples-removal-format</h3><div class="usage"><code>(triples-removal-format triples-spec)</code></div><div class="doc"><pre class="plaintext">Returns a keyword describing the format of `triples-spec` for removing a
set of triples from a graph.
</pre></div></div><div class="public anchor" id="var-unique"><h3>unique</h3><div class="usage"><code>(unique coll on-ambiguity)</code><code>(unique coll)</code></div><div class="doc"><pre class="plaintext">Returns the single member of `coll`, or nil if `coll` is empty. Calls `on-ambiguity` if there is more than one member (default is to throw an Exception).
Where
-   `coll` is a collection
-   `on-ambiguity` := (fn [coll] ...) -&gt; `value`, default raises an error.
Note: this can be used when you've called (G s p) and you're sure there is
  only one object.
</pre></div></div><div class="public anchor" id="var-write-to-file"><h3>write-to-file</h3><div class="usage"><code>(write-to-file path g)</code></div><div class="doc"><pre class="plaintext">Side-effect: writes normal form of `g` to `path` as edn.
  Returns: `path`
Where
  - `path` is the output of `path-fn`
  - `g` implements IGraph
  - `path-fn` a function [g] -&gt; `path`.
NOTE: Anything that would choke the reader on slurp should be removed 
  from `g` before saving.</pre></div></div></div></body></html>